package com.bbva.hancock.sdk;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import com.bbva.hancock.sdk.config.HancockConfig;
import com.bbva.hancock.sdk.config.HancockConfigAdapter;
import com.bbva.hancock.sdk.config.HancockConfigNode;

import com.bbva.hancock.sdk.models.EthereumTransferRequest;
import com.bbva.hancock.sdk.models.EthereumTransferResponse;
import com.bbva.hancock.sdk.models.GetBalanceResponse;
import com.bbva.hancock.sdk.models.HancockProtocolAction;
import com.bbva.hancock.sdk.models.HancockProtocolDecodeRequest;
import com.bbva.hancock.sdk.models.HancockProtocolDecodeResponse;
import com.bbva.hancock.sdk.models.HancockProtocolDlt;
import com.bbva.hancock.sdk.models.HancockProtocolEncodeResponse;
import com.bbva.hancock.sdk.models.TransactionConfig;

import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.OkHttpClient;
import okhttp3.Request;

import org.junit.Test;
import org.junit.runner.RunWith;
//import org.mockito.InjectMocks;
//import org.mockito.Mock;
//import org.mockito.invocation.InvocationOnMock;
//import org.mockito.junit.MockitoJUnitRunner;
//import org.mockito.stubbing.Answer;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.mockito.PowerMockito.spy;
import static org.powermock.api.mockito.PowerMockito.when;
import org.web3j.crypto.*;
import org.web3j.protocol.core.Response;
import org.web3j.utils.Numeric;
import org.junit.BeforeClass;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PowerMockIgnore;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;
import org.powermock.modules.junit4.PowerMockRunnerDelegate;

import java.io.IOException;
import java.math.BigInteger;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@PowerMockIgnore("javax.net.ssl.*")
//@RunWith(MockitoJUnitRunner.class)
@RunWith(PowerMockRunner.class)
@PrepareForTest({TransactionEncoder.class,Credentials.class,EthereumRawTransaction.class,RawTransaction.class,
  OkHttpClient.class,Call.class,okhttp3.Response.class,okhttp3.Request.class,GetBalanceResponse.class})
public class HancockEthereumClientTest {
  
    public static HancockConfig mockedConfig;
    public static EthereumWallet mockedWallet;
//    @Mock
    public static EthereumRawTransaction mockedEthereumRawTransaction;
    public static EthereumTransferRequest mockedEthereumTransferRequest;
    //@InjectMocks
    //@Mock
    public static HancockEthereumClient mockedHancockEthereumClient;
    //@Mock
    //private static TransactionEncoder mockedTransactionEncoder;
//    @Mock
//    private static Credentials mockedCredentials;
//    @Mock
//    private OkHttpClient httpMocks;
    @BeforeClass
    public static void setUp() throws Exception{
      //mockedHancockEthereumClient = mock(HancockEthereumClient.class);
      mockedConfig = new HancockConfig.Builder()
          .withEnv("custom")
          .withNode("http://mock.node.com", 9999)
          .withAdapter("http://mock.adapter.com", "/base", 9999)
          .build();
      mockedHancockEthereumClient = new HancockEthereumClient();
      mockedWallet = new EthereumWallet("0xmockAddress","mockPrivateKey","mockPublicKey");
      
      BigInteger nonce = BigInteger.valueOf(1);
      BigInteger gasPrice = BigInteger.valueOf(111);
      BigInteger gasLimit = BigInteger.valueOf(222);
      BigInteger value = BigInteger.valueOf(333);
      String from = mockedWallet.getAddress();
      String to = mockedWallet.getAddress();
      String data = "0xwhatever";
      
      mockedEthereumTransferRequest = new EthereumTransferRequest(from, to, value.toString(), data);
      mockedEthereumRawTransaction = new EthereumRawTransaction(nonce, gasPrice, gasLimit, to, value);
      //mockedCredentials = Credentials.create("0xde8e772f0350e992ddef81bf8f51d94a8ea9216d");
  
      //when(mockedHancockEthereumClient.generateWallet()).thenReturn(mockedWallet);
  
    }
  
    @Test public void testDumb()  {

        String test = "TEST";
        assertEquals(test, "TEST");

    }

    @Test public void testConfigInstantiation() throws Exception {


        assertEquals(mockedConfig.getEnv(), "custom");

        HancockConfigNode node = mockedConfig.getNode();
        assertEquals(node.getHost(), "http://mock.node.com");
        assertEquals(node.getPort(), 9999);

        HancockConfigAdapter adapter = mockedConfig.getAdapter();
        assertEquals(adapter.getHost(), "http://mock.adapter.com");
        assertEquals(adapter.getBase(), "/base");
        assertEquals(adapter.getPort(), 9999);
        assertEquals(adapter.getResources().get("balance"), "/ethereum/balance/__ADDRESS__");

    }

    @Test public void testGenerateWallet() throws Exception {

        assertTrue("Wallet should have an address", mockedWallet.getAddress() instanceof String);
        assertTrue("Wallet should have a publicKey", mockedWallet.getPublicKey() instanceof String);
        assertTrue("Wallet should have a privateKey", mockedWallet.getPrivateKey() instanceof String);
        
        assertEquals(mockedWallet.getAddress(), "0xmockAddress");
        assertEquals(mockedWallet.getPrivateKey(), "mockPrivateKey");
        assertEquals(mockedWallet.getPublicKey(), "mockPublicKey");

    }

    @Test public void testGetBalance() throws Exception {

        //when(mockedHancockEthereumClient.getBalance("0xmockAddress")).thenReturn(BigInteger.valueOf(0));
        OkHttpClient httpClient = mock(OkHttpClient.class);
        //okhttp3.Response  mockedResponse = mock(okhttp3.Response.class);
        Call response = mock(Call.class); 
        when(httpClient.newCall(any(Request.class))).thenReturn(response);
        when(response.execute()).thenReturn(mock(okhttp3.Response.class));
      
        GetBalanceResponse responseModel= mock(GetBalanceResponse.class);
        HancockEthereumClient auxHancockEthereumClient = new HancockEthereumClient();
        HancockEthereumClient spy_var=PowerMockito.spy(auxHancockEthereumClient);
        PowerMockito.doReturn(responseModel).when(spy_var).checkStatus(any(okhttp3.Response.class), eq(GetBalanceResponse.class)); 
        //when(auxHancockEthereumClient.checkStatus(any(okhttp3.Response.class), eq(GetBalanceResponse.class))).thenReturn(responseModel);
        when(responseModel.getBalance()).thenReturn("0");
        
        BigInteger balance = spy_var.getBalance("0xmockAddress");
        System.out.println("balance  "+balance);
        assertTrue("Wallet should have a Balance", balance instanceof BigInteger);
        assertEquals(balance, BigInteger.valueOf(0));
//        assertEquals(mockedHancockEthereumClient.getBalance("0xmockAddress"), new BigInteger(responseModel.getBalance()));

    }
    
    @Test public void testSignTransaction() throws Exception {
      
      
      //EthereumWallet wallet = mockedHancockEthereumClient.generateWallet();

//      BigInteger nonce = BigInteger.valueOf(1);
//      BigInteger gasPrice = BigInteger.valueOf(111);
//      BigInteger gasLimit = BigInteger.valueOf(222);
//      BigInteger value = BigInteger.valueOf(333);
//      String to = mockedWallet.getAddress();
//      String privateKey = mockedWallet.getPrivateKey();
//
//      System.out.println("oooooooooooook  "+privateKey);
//      EthereumRawTransaction rawTransaction = new EthereumRawTransaction(nonce, gasPrice, gasLimit, to, value);

//        when(mockedCredentials.create("mockPrivateKey")).thenAnswer(new Answer<Credentials>(){
//
//        @Override
//        public Credentials answer(InvocationOnMock invocation) throws Throwable {
//            
//            Object[] arguments = invocation.getArguments();
//            
//            if (arguments != null && arguments.length > 0 && arguments[0] != null){
//                
//              return mockedCredentials;
//            }
//            
//            return null;
//          }
//        });
//      
        //Credentials credential = mock(Credentials.class);
        PowerMockito.mockStatic(Credentials.class);
        when(Credentials.create("mockPrivateKey")).thenReturn(mock(Credentials.class));
        //when(credential.create("mockPrivateKey")).thenReturn(credential);
//        EthereumRawTransaction raw = mock(EthereumRawTransaction.class);
//        RawTransaction mockRaw = raw.getWeb3Instance();
        PowerMockito.mockStatic(RawTransaction.class);
        EthereumRawTransaction mockEthereumRawTransaction = mock(EthereumRawTransaction.class);
        when(mockEthereumRawTransaction.getWeb3Instance()).thenReturn(mock(RawTransaction.class));
        //TransactionEncoder mockeTransactionEncoder = mock(TransactionEncoder.class);
        //System.out.println("oooooooooooook  "+mockedTransactionEncoder);
        byte[] aux = "mockedsignedTransaction".getBytes();
//        System.out.println("oooooooooooook  "+Numeric.toHexString(aux));
        PowerMockito.mockStatic(TransactionEncoder.class);
        when(TransactionEncoder.signMessage(any(RawTransaction.class), any(Credentials.class))).thenReturn(aux);        

        //when(mockedHancockEthereumClient.signTransaction(mockedEthereumRawTransaction,"mockPrivateKey")).thenReturn("mockedsignedTransaction");

        String signedTransaction = mockedHancockEthereumClient.signTransaction(mockEthereumRawTransaction,"mockPrivateKey");
        System.out.println("sign  "+signedTransaction);
        assertTrue("transaction signed successfully",  signedTransaction instanceof String);
        //assertEquals(mockedHancockEthereumClient.signTransaction(mockedEthereumRawTransaction,"mockPrivateKey"), "mockedsignedTransaction");
        assertEquals(signedTransaction,  Numeric.toHexString(aux));

    }
    
    @Test public void testCreateRawTransaction() throws Exception {

        assertTrue("RawTransaction is well constructed ", mockedEthereumRawTransaction instanceof EthereumRawTransaction);
        assertTrue("RawTransaction web3 instance is well constructed ", mockedEthereumRawTransaction.getWeb3Instance() instanceof RawTransaction);
        assertTrue("RawTransaction has nonce ", mockedEthereumRawTransaction.getNonce() instanceof BigInteger);
        assertTrue("RawTransaction has gasPrice ", mockedEthereumRawTransaction.getGasPrice() instanceof BigInteger);
        assertTrue("RawTransaction has gasLimit ", mockedEthereumRawTransaction.getGasPrice() instanceof BigInteger);
        assertTrue("RawTransaction has to ", mockedEthereumRawTransaction.getTo() instanceof String);
        assertTrue("RawTransaction has value ", mockedEthereumRawTransaction.getValue() instanceof BigInteger);
        assertTrue("RawTransaction has value ", mockedEthereumRawTransaction.getData() instanceof String);

    }

     @Test public void testAdaptTransfer() throws Exception {

       OkHttpClient httpClient = mock(OkHttpClient.class);
       Call response = mock(Call.class); 
       when(httpClient.newCall(any(okhttp3.Request.class))).thenReturn(response);
       when(response.execute()).thenReturn(mock(okhttp3.Response.class));
     
       EthereumTransferResponse responseModel= mock(EthereumTransferResponse.class);
       okhttp3.Request requestMock= mock(okhttp3.Request.class);
       HancockEthereumClient auxHancockEthereumClient = new HancockEthereumClient();
       HancockEthereumClient spy_var=PowerMockito.spy(auxHancockEthereumClient);
       PowerMockito.doReturn(requestMock).when(spy_var).getRequest(any(String.class), any(okhttp3.RequestBody.class));
       PowerMockito.doReturn(responseModel).when(spy_var).checkStatus(any(okhttp3.Response.class), eq(EthereumTransferResponse.class)); 
       PowerMockito.whenNew(EthereumRawTransaction.class).withAnyArguments().thenReturn(mockedEthereumRawTransaction);
       
       EthereumRawTransaction transfer = spy_var.adaptTransfer(mockedEthereumTransferRequest);
       System.out.println("Adapter  "+transfer.getNonce()+ mockedEthereumRawTransaction.getNonce());
       assertTrue("Wallet should have a Balance", transfer instanceof EthereumRawTransaction);
       assertEquals(transfer, mockedEthereumRawTransaction);
//       assertEquals(mockedHancockEthereumClient.getBalance("0xmockAddress"), new BigInteger(responseModel.getBalance()));

       
     }

     @Test public void testsendSignedTransaction() throws Exception {

       //when(mockedHancockEthereumClient.sendSignedTransaction(eq("mockSignedTransaction"), eq(true), any(String.class))).thenReturn("mockSignedTransaction");
       when(mockedHancockEthereumClient.sendSignedTransaction("mockSignedTransaction", true, "mockUrl")).thenReturn("mockSignedTransaction");

       //verify(mockedHancockEthereumClient, atLeastOnce());
       
       String mockResult = mockedHancockEthereumClient.sendSignedTransaction("mockSignedTransaction", true, "mockUrl");
       System.out.println("signed: "+ mockResult);
       assertEquals(mockResult, "mockSignedTransaction");
       assertTrue("transaction send and signed successfully", mockResult instanceof String);

   }
     
     @Test public void testTransfer() throws Exception {
  
         TransactionConfig mockTransactionConfig = mock(TransactionConfig.class);
  
//         when(mockTransactionConfig.getSendLocally()).thenReturn(true);
//         when(mockTransactionConfig.getPrivateKey()).thenReturn("mockedPrivateKey");
//         when(mockedHancockEthereumClient.sendSignedTransaction("signedTransaction", mockTransactionConfig.getSendLocally(), "url")).thenReturn("mockedSignedTransaction");
      
         when(mockedHancockEthereumClient.transfer(mockedEthereumTransferRequest, mockTransactionConfig)).thenReturn("mockedSignedTransaction");
  
         String rawtx = mockedHancockEthereumClient.transfer(mockedEthereumTransferRequest, mockTransactionConfig);         

         assertTrue("transaction adapted successfully", rawtx instanceof String);
         verify(mockedHancockEthereumClient, atLeastOnce()).transfer(mockedEthereumTransferRequest, mockTransactionConfig);

         System.out.println("rawtx =>" + rawtx);

     }

    @Test public void testDecodeProtocol() throws Exception {

        HancockProtocolDecodeResponse mockHancockProtocolDecodeResponse = mock(HancockProtocolDecodeResponse.class);
      
//        HancockConfig config = new HancockConfig.Builder()
//                .withAdapter("http://localhost","", 3004)
//                .build();
//        HancockEthereumClient classUnderTest = new HancockEthereumClient(config);
//
//        HancockProtocolDecodeResponse response = classUnderTest.decodeProtocol("hancock://qr?code=%7B%22action%22%3A%22transfer%22%2C%22body%22%3A%7B%22value%22%3A%2210%22%2C%22data%22%3A%22dafsda%22%2C%22to%22%3A%220x1234%22%7D%2C%22dlt%22%3A%22ethereum%22%7D");
//
//        assertTrue("transaction signed successfully", response.getTo().equals("0x1234"));
        
        when(mockedHancockEthereumClient.decodeProtocol("mockedCode")).thenReturn(mockHancockProtocolDecodeResponse);
        
        assertTrue("transaction decode successfully", mockHancockProtocolDecodeResponse instanceof HancockProtocolDecodeResponse);
        //verify(mockedHancockEthereumClient, atLeastOnce()).decodeProtocol("mockedCode");
        System.out.println("Action =>" + mockHancockProtocolDecodeResponse.getAction());

    }

    @Test public void testEncodeProtocol() throws Exception {

      HancockProtocolEncodeResponse mockHancockProtocolEncodeResponse = mock(HancockProtocolEncodeResponse.class);
      
//        HancockConfig config = new HancockConfig.Builder()
//                .withAdapter("http://localhost","", 3004)
//                .build();
//        HancockEthereumClient classUnderTest = new HancockEthereumClient(config);
//
//        HancockProtocolEncodeResponse response = classUnderTest.encodeProtocol(HancockProtocolAction.transfer, new BigInteger("10"), "0x1234", "dafsda", HancockProtocolDlt.ethereum);
//
//        assertTrue("transaction signed successfully", response.getCode().equals("hancock://qr?code=%7B%22action%22%3A%22transfer%22%2C%22body%22%3A%7B%22value%22%3A%2210%22%2C%22data%22%3A%22dafsda%22%2C%22to%22%3A%220x1234%22%7D%2C%22dlt%22%3A%22ethereum%22%7D"));

      when(mockedHancockEthereumClient.encodeProtocol(HancockProtocolAction.transfer, BigInteger.valueOf(0), mockedWallet.getAddress(), "0xwhatever", HancockProtocolDlt.ethereum)).thenReturn(mockHancockProtocolEncodeResponse);
      
      assertTrue("transaction encode successfully", mockHancockProtocolEncodeResponse instanceof HancockProtocolEncodeResponse);
      //verify(mockedHancockEthereumClient, atLeastOnce()).encodeProtocol(HancockProtocolAction.transfer, BigInteger.valueOf(0), mockedWallet.getAddress(), "0xwhatever", HancockProtocolDlt.ethereum);
      System.out.println("Action =>" + mockHancockProtocolEncodeResponse.getCode());
      
    }
}
